
Supposons que nous avons dans notre base de données l'adresse *Address (id: 10, street: 6 Parvis Notre-Dame - Pl. Jean-Paul II, city: Paris, country: France)*. N'hésitez pas à la créer pour tester par vous-même.

Nous connaissons l'identifiant de l'adresse (10) et nous voulons l'associer à un utilisateur (Id: 7) déjà existant.

Nous avons le choix entre faire une requête pour récupérer l'adresse et une autre pour récupérer l'utilisateur avant de sauvegarder nos modifications. 
Ou alors nous pouvons utiliser un type d'objet appelé : référence.

Les références sont des objets qui permettent d'avoir une instance d'une entité dont on connait l'identifiant sans accéder à la base de données.

Ce sont des proxies *Doctrine* qui permettent d'utiliser facilement une entité dans une relation. 


```php
<?php
# set-user-address.php

$entityManager = require_once join(DIRECTORY_SEPARATOR, [__DIR__, 'bootstrap.php']);

use Tuto\Entity\User;
use Tuto\Entity\Address;

$userRepo = $entityManager->getRepository(User::class);
$logger = $entityManager->getConfiguration()->getSQLLogger();

$user =  $userRepo->find(7);

$address = $entityManager->getReference(Address::class, 10);

$user->setAddress($address);

$entityManager->flush();

echo "\nPerformances:\n";
echo "Nombre de requêtes : ", count($logger->queries), "\n";

foreach ($logger->queries as $query) {
    echo "- ", json_encode($query), "\n";
}
```

```txt
Performances:
Nombre de requêtes : 4
- {"sql":"SELECT u0_.id AS id_0, u0_.firstname AS firstname_1, u0_.lastname AS lastname_2, u0_.role AS role_3, a1_.id AS id_4, a1_.street AS street_5, a1_.city AS city_6, a1_.country AS country_7, p2_.id AS id_8, p2_.date AS date_9, u0_.address_id AS address_id_10, p2_.user_id AS user_id_11, p2_.poll_id AS poll_id_12 FROM users u0_ LEFT JOIN addresses a1_ ON u0_.address_id = a1_.id LEFT JOIN participations p2_ ON u0_.id = p2_.user_id WHERE u0_.id = ?","params":[7],"types":["integer"],"executionMS":0.24201416969299}
- {"sql":"\"START TRANSACTION\"","params":null,"types":null,"executionMS":0.027002096176147}
- {"sql":"UPDATE users SET address_id = ? WHERE id = ?","params":[10,7],"types":["integer","integer"],"executionMS":0.020001173019409}
- {"sql":"\"COMMIT\"","params":null,"types":null,"executionMS":0.0049998760223389}
```

Les références sont construites autour du principe de *lazy-loading*. Dès que nous essayerons d'accéder ou de modifier un de ses attributs, *Doctrine* chargera toutes ses informations depuis la base de données. 
Mais vous remarquerez en consultant les logs des requêtes SQL qu'en aucun cas l'adresse n'est récupérée pour mettre à jour l'utilisateur.