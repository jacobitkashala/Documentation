# Les types d'événements

Pour nous permettre d'agir sur les entités durant leur cycle de vie, l'*entity manager* de *Doctrine* génère des événements pour chaque opération qu'il effectue sur une entité. Ainsi, nous avons à notre disposition un ensemble d'événements et nous pouvons citer entre autres :

->

|Événement | Description             |
|----------| ------------------------------------------------------------|
|preRemove| L'événement déclenché avant que l'*entity manager* supprime l' entité.|
|postRemove| L'événement déclenché après la suppression effective de l'entité.|
|prePersist| L'événement déclenché avant que l'*entity manager* sauvegarde l' entité.|
|postPersist| L'événement déclenché après la sauvegarde effective de l'entité.|
|preUpdate| L'événement déclenché avant la mise à jour de l'entité.|
|postUpdate| L'événement déclenché après la mise à jour effective de l'entité.|
|postLoad| L'événement déclenché une fois qu'une entité a été chargée depuis la base de données (ou après l'appel de la méthode `refresh` de l'*entity manager*).|
|preFlush|L'événement déclenché juste avant la mise à jour effective de l'entité.|
|postFlush|L'événement déclenché après la mise à jour effective de l'entité.|

<-

[[erreur]]
| Ces événements ne sont pas déclenchés pour les requêtes DQL.

# Les méthodes de rappel (*callbacks*)

Nous pouvons modifier la gestion de nos entités en nous basant sur ces événements grâce aux fonctions de rappels. Ces fonctions seront appelées automatiquement par *Doctrine*.

Pour la création d'un sondage, nous avions dû rajouter la date de création manuellement. Avec les événements, nous pouvons avoir une méthode simple qui modifie la date de création lorsque l'événement `prePersist` est déclenché.

Pour cela, nous devons d'abord spécifier que l'entité *sondage* utilise les événements de *Doctrine* avec l'annotation `HasLifecycleCallbacks `.
Ensuite, nous pourrons utiliser les annotations pour désigner les méthodes qui seront appelées si un événement spécifique est déclenché.
Ainsi pour l'entité sondage, nous aurons :

```php
<?php
# src/Entity/Poll.php

namespace Tuto\Entity;

use Doctrine\Common\Collections\ArrayCollection;
use Doctrine\ORM\Mapping as ORM;

/**
* @ORM\Entity
* @ORM\Table(name="polls")
* @ORM\HasLifecycleCallbacks
*/
class Poll
{
    // ...

    /**
    * @ORM\PrePersist
    */
    public function prePersist()
    {
        $this->created = new \Datetime();
    }
}
```

```php
<?php
# create-poll-prepersist.php

$entityManager = require_once join(DIRECTORY_SEPARATOR, [__DIR__, 'bootstrap.php']);

use Tuto\Entity\Poll;

$poll = new Poll();

$poll->setTitle("Les événements Doctrine 2");

$entityManager->persist($poll);

$entityManager->flush();

echo $poll;
```

Notre méthode `prePersist` est appelée automatiquement par *Doctrine* et le sondage a ainsi une date de création.

```txt
Poll (id: 2, title: Les événements Doctrine 2, created: 2017-01-22T22:03:02+0000)
```

Ces événements permettent de personnaliser grandement le comportement de *Doctrine*. Ils sont d'ailleurs utilisés par beaucoup d'extensions pour gérer des problématiques courantes. N'hésitez donc pas les consulter pour approfondir le sujet ([Atlantic18/DoctrineExtensions](https://github.com/Atlantic18/DoctrineExtensions)).

Le système d'événement peut même être poussé encore plus loin en créant par exemple nos propres événements, des classes spécialisées pour gérer les événements, etc. [La documentation officielle](http://docs.doctrine-project.org/projects/doctrine-orm/en/latest/reference/events.html) présente bien ces sujets.
