# Définition

La gestion des relations bidirectionnelles par *Doctrine* n'est pas une tâche anodine.

Si nous récupérons un sondage de la base de données et que nous modifions la liste des questions qui lui sont associées (en retirant une question par exemple), à la sauvegarde des modifications, la question retirée sera toujours liée au sondage.

```php
<?php
# owning-side-inverse-side.php

$entityManager = require_once join(DIRECTORY_SEPARATOR, [__DIR__, 'bootstrap.php']);
$logger = $entityManager->getConfiguration()->getSQLLogger();

use Tuto\Entity\Poll;

$pollRepo = $entityManager->getRepository(Poll::class);

$poll = $pollRepo->find(1);

echo $poll;

$questions = $poll->getQuestions();

$questions->remove(1);

$entityManager->flush();

echo "\nPerformances:\n";
echo "Nombre de requêtes : ", count($logger->queries), "\n";

foreach ($logger->queries as $query) {
    echo "- ", json_encode($query), "\n";
}
```

```txt
Poll (id: 1, title: Doctrine 2, ça vous dit ?, created: 2017-03-03T08:00:00+0000)

Performances:
Nombre de requêtes : 4
- {"sql":"SELECT t0.id AS id_1, t0.title AS title_2, t0.created AS created_3 FROM polls t0 WHERE t0.id = ?","params":[1],"types":["integer"],"executionMS":0.1620090007782}
- {"sql":"SELECT t0.id AS id_1, t0.wording AS wording_2, t0.poll_id AS poll_id_3 FROM questions t0 WHERE t0.poll_id = ?","params":[1],"types":["integer"],"executionMS":0.10100603103638}
- {"sql":"\"START TRANSACTION\"","params":null,"types":null,"executionMS":0.016000986099243}
- {"sql":"\"COMMIT\"","params":null,"types":null,"executionMS":0}
[Finished in 0.6s]
```

Aucune requête de mise à jour n'a été exécutée.

En réalité, dans toutes les relations, *Doctrine* ne vérifie les changements que d'un seul côté pour mettre à jour la relation. Ce côté **responsable** de la relation est appelé l'*owning side*. Réciproquement, l'autre côté de la relation est appelé l'*inverse side*.

# Identification de l'*owning side*

[[question]]
| Comment idenfier l'*owning side* d'une relation ?

Selon le type de relation bidirectionnelle utilisé, l'*owning side* peut être soit imposé par *Doctrine* soit choisi par nous-même.

Pour une relation *ManyToOne - OneToMany*, l'*owning side* sera toujours l'entité contenant l'annotation `ManyToOne`. Dans ce cas-ci, *Doctrine* impose le choix.

Par contre, pour les relations *OneToOne* et *ManyToMany* bidirectionnelles, nous devons nous-même choisir l'*owning side* en spécifiant l'attribut `inversedBy`.

Ainsi pour supprimer une question d'un sondage, nous devons modifier la relation en nous basant sur l'entité *question* qui est l'*owning side* de la relation car elle contient l'annotation `ManyToOne`.

La suppression ressemblerait donc à :

```php
<?php
# owning-side-inverse-side.php

$entityManager = require_once join(DIRECTORY_SEPARATOR, [__DIR__, 'bootstrap.php']);
$logger = $entityManager->getConfiguration()->getSQLLogger();

use Tuto\Entity\Question;

$questionRepo = $entityManager->getRepository(Question::class);

$question = $questionRepo->find(2);

echo $question;

$question->setPoll(null);

$entityManager->flush();

echo "\nPerformances:\n";
echo "Nombre de requêtes : ", count($logger->queries), "\n";

foreach ($logger->queries as $query) {
    echo "- ", json_encode($query), "\n";
}
```

```txt
Question (id: 2, wording: Doctrine 2 est-il un bon ORM ?)

Performances:
Nombre de requêtes : 4
- {"sql":"SELECT t0.id AS id_1, t0.wording AS wording_2, t0.poll_id AS poll_id_3 FROM questions t0 WHERE t0.id = ?","params":[2],"types":["integer"],"executionMS":0.014001131057739}
- {"sql":"\"START TRANSACTION\"","params":null,"types":null,"executionMS":0.0010001659393311}
- {"sql":"UPDATE questions SET poll_id = ? WHERE id = ?","params":[null,2],"types":["integer","integer"],"executionMS":0.35101985931396}
- {"sql":"\"COMMIT\"","params":null,"types":null,"executionMS":0.26401495933533}
[Finished in 1.2s]
```

Notez la présence de la requête `UPDATE questions SET poll_id = ? WHERE id = ?` qui permet ainsi de dissocier la question au sondage.

# Contraintes

Ce mode de fonctionnement interne de *Doctrine* introduit quelques contraintes d'utilisation de l'ORM. Dans toutes les relations unidirectionnelles, seul l'*owning side* doit être configuré.

Ainsi, pour une relation 1..n unidirectionnelle, seul l'annotation `ManyToOne` doit être configurée.

En d'autres termes, l'annotation `OneToMany` ne peut être utilisée toute seule. À chaque annotation `OneToMany`, il **doit** y avoir une annotation `ManyToOne` correspondante.

Dans la même logique, pour une relation 1..1 unidirectionnelle, une seule entité contient l'annotation `OneToOne`. *Doctrine* créera forcément la clé étrangère dans cette entité.

C'est le cas pour notre relation entre un utilisateur et une adresse. La clé étrangère est dans la table `users` car l'entité *utilisateur* est l'*owning side*.


[[information]]
| De manière générale, en plus d'être complexes, les relations bidirectionnelles sont souvent une source de problèmes de performance. Avant de les utiliser, il faut toujours évaluer la réelle nécessité d'une telle configuration.