Beaucoup de moteur de base de données fournissent le mécanisme de transaction afin d'assurer l'atomicité d'un ensemble de requêtes.

[[information]]
| L'atomicité est une propriété qui désigne une opération ou un ensemble d'opérations en mesure de s'exécuter complétement sans interruption.

Un ensemble de requêtes sera considéré comme atomique si nous avons la garantie qu'elles seront toutes exécutées ensemble. Pour obtenir un tel résultat, *Doctrine* fournit une API nous permettant d'exploiter le mécanisme de transaction des bases de données relationnelles.

# Transactions implicites

Lorsque que nous utilisons l'*entity manager*, *Doctrine* crée automatiquement une transaction afin d'assurer que nos opérations se déroulent correctement. Ainsi, toutes les opérations déclarées avant l'appel de la méthode `flush` de l'*entity manager* sont exécutées dans une même transaction.
Nous pouvons ainsi effectuer sereinement toutes les modifications que nous voulons sur notre modèle de données avant d'effectuer les requêtes SQL associées.

```php
<?php
# create-user-with-address.php

$entityManager = require_once join(DIRECTORY_SEPARATOR, [__DIR__, 'bootstrap.php']);
$logger = $entityManager->getConfiguration()->getSQLLogger();

use Tuto\Entity\User;
use Tuto\Entity\Address;

// Instanciation de l'utilisateur

$user = new User();
$user->setFirstname("First with Address");
$user->setLastname("Lastname");
$user->setRole("admin");

// Création de l'adresse
$address = new Address();
$address->setStreet("Place Charles de Gaulle");
$address->setCity("Paris");
$address->setCountry("France");

$user->setAddress($address);

// Gestion de la persistance
/*
Le premier persist n'est pas obligatoire car il y a une opération de cascade
sur l'addresse
*/
$entityManager->persist($address);
$entityManager->persist($user);
$entityManager->flush();

// Vérification du résultats
echo $user;

echo "Nombre de requêtes : ", count($logger->queries), "\n";

foreach ($logger->queries as $query) {
    echo "- ", json_encode($query), "\n";
}
```

En exécutant ce code, *Doctrine* exécute quatre (4) requêtes dont une pour démarrer la transaction (`START TRANSACTION`) et une autre pour la valider (`COMMIT`).

```txt
User (id: 13, firstname: First with Address, lastname: Lastname, role: admin, address: Address (id: 9, street: Place Charles de Gaulle, city: Paris, country: France))
Nombre de requêtes : 4
- {"sql":"\"START TRANSACTION\"","params":null,"types":null,"executionMS":0.083003997802734}
- {"sql":"INSERT INTO addresses (street, city, country) VALUES (?, ?, ?)","params":{"1":"Place Charles de Gaulle","2":"Paris","3":"France"},"types":{"1":"string","2":"string","3":"string"},"executionMS":1.1140639781952}
- {"sql":"INSERT INTO users (firstname, lastname, role, address_id) VALUES (?, ?, ?, ?)","params":{"1":"First with Address","2":"Lastname","3":"admin","4":9},"types":{"1":"string","2":"string","3":"string","4":"integer"},"executionMS":1.9531121253967}
- {"sql":"\"COMMIT\"","params":null,"types":null,"executionMS":0.1080060005188}
[Finished in 4.7s]
```

# Transactions explicites

Il est toujours possible d'activer les transactions à la demande. Si par exemple nous voulons supporter la suppression d'un sondage. Il serait intéressant de pouvoir faire toutes les suppressions nécessaires (le sondage, les questions, les réponses, les participations, les choix des utilisateurs liés à ce sondage) dans une même transaction.

Pour créer une transaction, nous devons utiliser directement la connexion à la base de données.

```php
<?php
// Démarrage de la transaction
$connection = $entityManager->getConnection();
$connection->beginTransaction(); 
try {
    // Suppression du sondage et de tous les éléments liés
    $connection->commit();
} catch (Exception $e) {
    // Si il y a un problème, nous annulons la transaction
    $connection->rollBack();
}

```

[[attention]]
| Lorsque nous démarrons manuellement une transaction, *Doctrine* désactive automatiquement les transactions implicites. L'appel à la méthode `flush` ne créera plus de transactions.

Il y a aussi une fonction utilitaire de l'*entity manager* permettant d'utiliser les transactions sans passer par la connexion.

```php
<?php
$entityManager->transactional(function($entityManager) {
    // opérations
});
```

Toutes les opérations dans la fonction anonyme passée à la méthode `transactional` seront exécutées dans une même transaction.