
Lorsque nous récupérons une classe depuis les *repositories*, *Doctrine* peut utiliser en interne des classes intermédiaires qui étendent les nôtres. Ces classes sont appelées des proxies. C'est d'ailleurs grâce à ces proxies que le système de lazy-loading peut fonctionner. Et c'est l'une de leur principale utilité.

Pour s'en rendre compte, nous allons modifier la configuration de *Doctrine*. Dans l'entité *utilisateur*, supprimons tous les fetch EAGER que nous avions configurés et exécutons le code suivant.

```php
<?php
# get-user-class.php

$entityManager = require_once join(DIRECTORY_SEPARATOR, [__DIR__, 'bootstrap.php']);

use Tuto\Entity\User;

$userRepo = $entityManager->getRepository(User::class);

$user = $userRepo->find(1);
echo get_class($user->getAddress());
```

La réponse est :

```php
DoctrineProxies\__CG__\Tuto\Entity\Address.
```

Sans nos optimisations, la classe `Address` est chargée en mode lazy-loading. *Doctrine* utilise donc un proxy.

Cette classe est déclarée dans le dossier temporaire de votre système (***/tmp*** sur linux, ***C:\\Users\\votre_utilisateur\\AppData\\Local\\Temp*** sur Windows). Vous pouvez trouver ce dossier en utilisant la fonction PHP `sys_get_temp_dir`.

Voici un extrait de son code :

```php
<?php
namespace DoctrineProxies\__CG__\Tuto\Entity;

/**
 * DO NOT EDIT THIS FILE - IT WAS CREATED BY DOCTRINE'S PROXY GENERATOR
 */
class Address extends \Tuto\Entity\Address implements \Doctrine\ORM\Proxy\Proxy
{
    // ...

    /**
     * {@inheritDoc}
     */
    public function getStreet()
    {
        $this->__initializer__ && $this->__initializer__->__invoke($this, 'getStreet', []);

        return parent::getStreet();
    }
}
```

La méthode `getStreet` comme toutes les méthodes de notre entité, ont été réécrites par *Doctrine*. Le secret du lazy-loading réside dans ce code. 

[[question]]
| Mais pourquoi parle-t-on des proxies ?

Avec la configuration actuelle, *Doctrine* est obligé de régénérer ces classes à chaque exécution. Les performances d'une application en production en pâtiraient énormément.
En production, nous devons désactiver cette génération automatique et créer les proxies manuellement grâce à la commande *Doctrine* appropriée : `vendor/bin/doctrine orm:generate-proxies`.