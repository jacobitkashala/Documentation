Prenons un exemple simple pour commencer.

```php
<?php
# get-user.php

$entityManager = require_once join(DIRECTORY_SEPARATOR, [__DIR__, 'bootstrap.php']);

use Tuto\Entity\User;

$userRepo = $entityManager->getRepository(User::class);
$logger = $entityManager->getConfiguration()->getSQLLogger();

$user = $userRepo->find(1);
$address = $user->getAddress();

echo "Find User\n";
echo "Firstname : ", $user->getFirstName(), "\n";

foreach ($logger->queries as $query) {
    echo "- ", json_encode($query), "\n";
}

echo "City :", $address->getCity(), "\n";

echo "After Print address\n";

echo "\nPerformances:\n";
echo "Nombre de requêtes : ", count($logger->queries), "\n";

foreach ($logger->queries as $query) {
    echo "- ", json_encode($query), "\n";
}
```

Lorsque que nous récupérons les informations sur un utilisateur avec une méthode `find`, *Doctrine* exécute une seule requête SQL pour récupérer les informations liées à notre utilisateur.

```sql
SELECT t0.id AS id_1, t0.firstname AS firstname_2, t0.lastname AS lastname_3, t0.role AS role_4, 
t0.address_id AS address_id_5 FROM users t0 WHERE t0.id = ?
```

Lorsque nous appelons la méthode `getAddress` Doctrine nous renvoie une entité *adresse* avec une grande subtilité : seul l'identifiant de celui est connu.
C'est lorsque nous essayons d'afficher une information différente de  l'identifiant de l'adresse (ici la ville) que *Doctrine* effectue une autre requête pour récupérer les informations de l'adresse.

```sql
SELECT t0.id AS id_1, t0.street AS street_2, t0.city AS city_3, t0.country AS country_4, t5.id AS id_6, 
t5.firstname AS firstname_7, t5.lastname AS lastname_8, t5.role AS role_9, t5.address_id AS address_id_10 
FROM addresses t0 LEFT JOIN users t5 ON t5.address_id = t0.id WHERE t0.id = ?
```

Cette technique est appelée le *lazy-loading*. Pour économiser les requêtes SQL, *Doctrine* utilise dès que possible cette technique.
Cependant dans certains cas, cette optimisation n'est pas utile et entraine même des pertes de performances. *Doctrine* nous laisse le choix de modifier ce comportement à notre guise.

Ainsi, pour les annotations permettant de gérer les relations, il y a un attribut `fetch` qui peut prendre trois valeurs.

*LAZY* est la valeur par défaut et son comportement est celui que nous venons de décrire.

*EAGER* permet d'utiliser une jointure et récupérer les deux entités en relation avec une seule requête.

Testons cette configuration.

```php
<?php
# src/Entity/User.php

namespace Tuto\Entity;

use Tuto\Repository\UserRepository;
use Doctrine\Common\Collections\ArrayCollection;
use Doctrine\ORM\Mapping as ORM;

// ...
class User
{
    // ...

    /**
    * @ORM\OneToOne(targetEntity=Address::class, cascade={"persist", "remove"}, inversedBy="user", fetch="EAGER")
    */
    protected $address;

    // ...
}
```

En ré-exécutant, notre exemple *Doctrine* utilise une seule requête pour récupérer l'utilisateur et son adresse.

```sql
SELECT t0.id AS id_1, t0.firstname AS firstname_2, t0.lastname AS lastname_3, t0.role AS role_4, 
t0.address_id AS address_id_5, t6.id AS id_7, t6.street AS street_8, t6.city AS city_9, t6.country AS country_10 
FROM users t0 LEFT JOIN addresses t6 ON t0.address_id = t6.id WHERE t0.id = ?
```

Nous pouvons dès à présent rajouter cette configuration dans les entités *choix* et *utilisateur* pour optimiser le nombre de requêtes exécutées par *Doctrine*.

```php
<?php
# src/Entity/Choice.php

namespace Tuto\Entity;

use Doctrine\Common\Collections\ArrayCollection;
use Doctrine\ORM\Mapping as ORM;

// ...
class Choice
{
    // ...

    /**
    * @ORM\ManyToOne(targetEntity=Question::class, fetch="EAGER")
    */
    protected $question;

    // ...
}
```

```php
<?php
# src/Entity/User.php

namespace Tuto\Entity;

use Tuto\Repository\UserRepository;
use Doctrine\Common\Collections\ArrayCollection;
use Doctrine\ORM\Mapping as ORM;

// ...
class User
{
    // ...

    /**
    * @ORM\OneToOne(targetEntity=Address::class, cascade={"persist", "remove"}, inversedBy="user", fetch="EAGER")
    */
    protected $address;

    /**
    * @ORM\OneToMany(targetEntity=Participation::class, mappedBy="user", fetch="EAGER")
    */
    protected $participations;

    // ...
}
```

Le nombre de requêtes est maintenant passé à cinq (5).

```txt
Performances:
Nombre de requêtes : 5
Durée d'exécution totale : 0.2850170135498 ms
- {"sql":"SELECT t0.id AS id_1, t0.firstname AS firstname_2, t0.lastname AS lastname_3, t0.role AS role_4, t0.address_id AS address_id_5, t6.id AS id_7, t6.street AS street_8, t6.city AS city_9, t6.country AS country_10, t11.id AS id_12, t11.date AS date_13, t11.user_id AS user_id_14, t11.poll_id AS poll_id_15 FROM users t0 LEFT JOIN addresses t6 ON t0.address_id = t6.id LEFT JOIN participations t11 ON t11.user_id = t0.id WHERE t0.id = ?","params":[3],"types":["integer"],"executionMS":0.056002855300903}
- {"sql":"SELECT t0.id AS id_1, t0.title AS title_2, t0.created AS created_3 FROM polls t0 WHERE t0.id = ?","params":[1],"types":["integer"],"executionMS":0.0040009021759033}
- {"sql":"SELECT t0.id AS id_1, t0.question_id AS question_id_2, t3.id AS id_4, t3.wording AS wording_5, t3.poll_id AS poll_id_6, t0.participation_id AS participation_id_7 FROM choices t0 LEFT JOIN questions t3 ON t0.question_id = t3.id WHERE t0.participation_id = ?","params":[1],"types":["integer"],"executionMS":0.00099992752075195}
- {"sql":"SELECT t0.id AS id_1, t0.wording AS wording_2, t0.question_id AS question_id_3 FROM answers t0 INNER JOIN selected_answers ON t0.id = selected_answers.answer_id WHERE selected_answers.choice_id = ?","params":[1],"types":["integer"],"executionMS":0.0010001659393311}
- {"sql":"SELECT t0.id AS id_1, t0.wording AS wording_2, t0.question_id AS question_id_3 FROM answers t0 INNER JOIN selected_answers ON t0.id = selected_answers.answer_id WHERE selected_answers.choice_id = ?","params":[2],"types":["integer"],"executionMS":0.092005014419556}
```

Et pour finir, pour les relations `ManyToMany` et `OneToMany`, il existe une option *EXTRA_LAZY*. Cette option permet d'interagir avec une collection mais en évitant au maximum de la charger entièrement en mémoire.

L'appel aux méthodes `contains($entity)`, `containsKey($key)`, `count()`, `get($key)`, `slice($offset, $length = null)`, `add($entity)` et `offsetSet($key, $entity)` de la collection ne déclenchera pas une requête de chargement de toutes les entités.

Si par exemple, nous avions la relation entre les utilisateurs et les participations en mode *EXTRA_LAZY*, un appel à la méthode `$user->getParticipations()->count()` se traduirait par une requête _SELECT COUNT(*)_.

Ce mode est utile si nous traitons une collection trop grandes et que nous voulons éviter de la charger en mémoire.
