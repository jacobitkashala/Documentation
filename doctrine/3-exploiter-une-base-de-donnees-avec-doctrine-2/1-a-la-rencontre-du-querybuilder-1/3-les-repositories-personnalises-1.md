# Configuration

Lorsque nous avions fait appel à l'*entity manager* pour récupérer un *repository*, *Doctrine* avait créé pour nous un *repository* qui dispose nativement d'un ensemble de méthodes utilitaires pour faire des requêtes de base.

Cependant, nous avons la possibilité, pour chaque entité, de personnaliser le *repository* que *Doctrine* va utiliser.

La configuration de celui-ci se fait en deux temps :

1. Pour commencer, il faut créer une classe qui étend la classe `EntityRepository` ;
2. Ensuite, il faut demander à *Doctrine* d'utiliser ce *repository*.

Nous allons tester cette configuration avec les utilisateurs. Le *repository* ressemble donc à :

```php
<?php
# src/Repository/UserRepository.php

namespace Tuto\Repository;

use Doctrine\ORM\EntityRepository;

class UserRepository extends EntityRepository
{
}
```

Pour l'utiliser, nous devons mettre à jour les annotations sur l'entité *utilisateur*. Vous l'aurez peut-être remarqué, les entités représente la glu entre notre code et *Doctrine*. Toutes les configurations se situent sur celles-ci. Cela permet de centraliser tout ce qui est lié à l'ORM.

Pour déclarer un *repository*, il suffit juste d'utiliser l'attribut `repositoryClass` de l'annotation `Entity`.

```php
<?php
# src/Entity/User.php

namespace Tuto\Entity;

use Tuto\Repository\UserRepository;
use Doctrine\Common\Collections\ArrayCollection;
use Doctrine\ORM\Mapping as ORM;

/**
* @ORM\Entity(repositoryClass=UserRepository::class)
* // ...
*/
class User
{
   // ...
}
```

Nous pouvons maintenant tester cette configuration.

```php
<?php
# custom-repository.php

$entityManager = require_once join(DIRECTORY_SEPARATOR, [__DIR__, 'bootstrap.php']);

use Tuto\Entity\User;
use Tuto\Entity\Poll;

$userRepo = $entityManager->getRepository(User::class);
echo get_class($userRepo), "\n";

$pollRepo = $entityManager->getRepository(Poll::class);
echo get_class($pollRepo), "\n";
```

Résultat :
```txt
Tuto\Repository\UserRepository # Notre classe est utilisée.
Doctrine\ORM\EntityRepository
```

Notre *repository* est bien récupéré par la méthode `getRepository`. Et puisque nous étendons la classe `EntityRepository`, les méthodes déjà vues durant ce cour sont tous valides. 

# Utilisation des *repositories* personnalisés

Ce *repository* peut maintenant être utilisé à la place du *repository* natif de *Doctrine*. Dans l'API de celui, nous disposons de plusieurs méthodes qui nous permettent d'accéder indirectement à l'*entity manager*.

Toutes les requêtes basées sur le *QueryBuilder* peuvent être ainsi encapsulées dans le *repository*. Le code utilisé reste identique à ce que nous avons déjà utilisé pour illustrer l'API du *QueryBuilder*.

```php
<?php
# src/Repository/UserRepository.php

namespace Tuto\Repository;

use Doctrine\ORM\EntityRepository;
use Tuto\Entity\User;

class UserRepository extends EntityRepository
{
    public function searchByFirstname($firstname)
    {
        $queryBuilder = $this_em->createQueryBuilder()
           ->select('u')
           ->from(User::class, 'u')
           ->where('u.firstname = :firstname')
           ->setParameter('firstname', $firstname);

        $query = $queryBuilder->getQuery();

        return $query->getOneOrNullResult();
    }

    public function deleteById($id)
    {
        $queryBuilder = $this_em->createQueryBuilder();
        $queryBuilder->delete(User::class, 'u')
           ->where('u.id = :id')
           ->setParameter('id', $id);

        $query = $queryBuilder->getQuery();

        return $query->execute();
    }
}
```

Maintenant à chaque fois que nous accédons au *repository*, nous pouvons utiliser ces méthodes.

```php
<?php
# custom-repository.php

$entityManager = require_once join(DIRECTORY_SEPARATOR, [__DIR__, 'bootstrap.php']);

use Tuto\Entity\User;

$userRepo = $entityManager->getRepository(User::class);

echo $userRepo->searchByFirstname("First");
```

```txt
User (id: 1, firstname: First, lastname: LAST, role: admin, 
address: Address (id: 1, street: Champ de Mars, 5 Avenue Anatole, city: Paris, country: France))
```

N'hésitez pas à implémenter les autres méthodes pour vous entrainer.


[[information]]
| Il est certes possible d'utiliser directement l'*entity manager* pour créer des *QueryBuilder*. Mais en les mettant dans des *repositories* personnalisés, nous pouvons centraliser toutes les requêtes et les réutiliser sans duplication de code.